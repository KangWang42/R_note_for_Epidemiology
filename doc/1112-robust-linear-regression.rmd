---
title: 稳健线性回归完全指南
date: '2026-01-24'
categories:
- 统计分析方法
- 基础回归
- 回归建模
image: images/robust-linear-regression-cover.svg
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 8,
  fig.height = 5,
  fig.retina = 2,
  out.width = "100%",
  dpi = 150
)
```

## 什么是稳健回归？

**稳健回归（Robust Regression）**是一类能够抵抗异常值和偏差影响的统计方法。相比于传统的最小二乘回归，稳健回归在存在以下问题时表现更好：

| 问题类型 | 传统OLS的问题 | 稳健回归的解决方案 |
|----------|---------------|-------------------|
| **异常值** | 受极值严重影响 | 使用稳健损失函数降低影响 |
| **异方差** | 标准误估计偏差 | 权重调整或稳健方差 |
| **偏态分布** | 假设正态性违背 | 非正态分布下的稳健估计 |
| **杠杆点** | 过度影响拟合线 | 诊断和重新加权 |

### 稳健回归的核心理念

```
传统OLS: 最小化 Σ(yi - ŷi)²
稳健回归: 最小化 ρ(yi - ŷi)，其中ρ是稳健损失函数
```

**常用稳健损失函数**：

| 函数 | 公式 | 特点 |
|------|------|------|
| **Huber** | ρ(x) = x²/2 (|x|≤k)<br>ρ(x) = k\|x\| - k²/2 (|x\|>k) | 平衡稳健性与效率 |
| **Tukey** | ρ(x) = 1 - (1 - (x/k)²)³ (|x\|≤k)<br>ρ(x) = 1 (|x\|>k) | 对远距离异常值完全忽略 |
| **Fair** | ρ(x) = c²[|x/c| - log(1 + |x/c|)] | 参数化控制稳健程度 |

---

## R 包安装与加载

```{r}
# 稳健回归核心包
library(MASS)           # rlm()稳健线性回归
library(quantreg)       # rq()分位数回归
library(lmtest)         # 检验统计量
library(sandwich)       # 稳健标准误
library(ggplot2)        # 可视化
library(patchwork)      # 图形组合
library(tidyverse)      # 数据处理

# 模型诊断包
library(car)           # 扩展的回归诊断
```

---

## 数据准备：血压与心血管风险研究

模拟心血管研究数据，包含真实的异常值和异方差情况：

```{r}
# 设置随机种子
set.seed(20250124)

# 模拟参数
n_patients <- 500

# 患者特征数据
cardio_data <- tibble(
  patient_id = 1:n_patients,
  
  # 主要预测变量
  age = pmax(25, pmin(85, round(rnorm(n_patients, 55, 12)))),  # 限制年龄范围
  
  bmi = pmax(15, pmin(45, round(rnorm(n_patients, 25, 4), 1))),  # BMI限制
  
  smoking = rbinom(n_patients, 1, 0.25),  # 吸烟状态
  sex = factor(sample(c("男", "女"), n_patients, replace = TRUE)),
  
  # 连续变量
  systolic_bp = rnorm(n_patients, 130, 15),
  cholesterol = round(rnorm(n_patients, 200, 30)),
  
  # 创建异常值（5%的患者有极端值）
  outlier_flag = sample(c(TRUE, FALSE), n_patients, replace = TRUE, prob = c(0.05, 0.95))
) |>
  mutate(
    # 正常患者的血压模型
    systolic_bp_normal = ifelse(!outlier_flag, 
                                110 + 0.8 * age + 0.6 * bmi + 
                                15 * smoking + rnorm(n(), 0, 10),
                                systolic_bp),
    
    # 异常值患者（极端高血压）
    systolic_bp_outliers = ifelse(outlier_flag,
                                  rnorm(sum(outlier_flag), 200, 20),
                                  systolic_bp_normal),
    
    systolic_bp = ifelse(outlier_flag, systolic_bp_outliers, systolic_bp_normal),
    
    # 胆固醇与血压的关系（含异方差）
    cholesterol_eff = 0.3 * systolic_bp + 
                      ifelse(outlier_flag, rnorm(sum(outlier_flag), 0, 50), rnorm(n(), 0, 20)),
    cholesterol = cholesterol + cholesterol_eff,
    
    # 结局变量（心血管事件风险评分）
    cvd_risk = 50 + 0.8 * age + 0.5 * (bmi - 25) + 20 * smoking + 
               0.4 * (systolic_bp - 120) + 0.1 * cholesterol + 
               ifelse(sex == "男", 10, 0) +
               rnorm(n(), 0, 15),
    
    # 分类结局
    cvd_event = ifelse(cvd_risk > 75, 1, 0),
    
    # 清理变量
    systolic_bp = round(systolic_bp),
    cholesterol = round(pmax(100, pmin(400, cholesterol))),
    cvd_risk = round(pmin(100, pmax(0, cvd_risk)))
  ) |>
  select(-systolic_bp_normal, -systolic_bp_outliers, -outlier_flag)

# 查看数据
glimpse(cardio_data)
```

### 数据探索

```{r fig.height=8}
# 血压分布及异常值识别
p1 <- ggplot(cardio_data, aes(x = systolic_bp)) +
  geom_histogram(binwidth = 5, fill = "#4f46e5", alpha = 0.7) +
  geom_vline(xintercept = mean(cardio_data$systolic_bp), color = "red", linetype = "dashed") +
  geom_vline(xintercept = quantile(cardio_data$systolic_bp, 0.95), color = "orange", linetype = "dashed") +
  labs(
    title = "收缩压分布",
    subtitle = "红线为均值，橙线为95%分位数",
    x = "收缩压 (mmHg)",
    y = "频数"
  ) +
  theme_minimal()

# 年龄与血压的关系
p2 <- ggplot(cardio_data, aes(x = age, y = systolic_bp, color = factor(smoking))) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = TRUE, aes(color = NULL), color = "black") +
  scale_color_manual(values = c("#10b981", "#ef4444"), name = "吸烟", labels = c("否", "是")) +
  labs(
    title = "年龄与血压关系",
    subtitle = "不同吸烟状态下的线性关系",
    x = "年龄",
    y = "收缩压 (mmHg)"
  ) +
  theme_minimal()

# BMI与血压散点图
p3 <- ggplot(cardio_data, aes(x = bmi, y = systolic_bp, color = factor(cvd_event))) +
  geom_point(alpha = 0.6) +
  geom_smooth(method = "lm", se = FALSE, color = "blue") +
  scale_color_manual(values = c("#6b7280", "#ef4444"), name = "心血管事件", labels = c("否", "是")) +
  labs(
    title = "BMI与血压关系",
    subtitle = "颜色表示是否发生心血管事件",
    x = "BMI (kg/m²)",
    y = "收缩压 (mmHg)"
  ) +
  theme_minimal()

p1 / (p2 + p3) + plot_layout(heights = c(1, 1))
```

### 异常值诊断

```{r}
# 传统OLS回归用于比较
ols_model <- lm(systolic_bp ~ age + bmi + smoking + cholesterol, data = cardio_data)

# 检测异常值
outliers <- cardio_data |>
  mutate(
    predicted = predict(ols_model),
    residuals = systolic_bp - predicted,
    standardized_resid = residuals / sigma(ols_model),
    cook_distance = cooks.distance(ols_model),
    leverage = hatvalues(ols_model)
  ) |>
  mutate(
    outlier_status = case_when(
      abs(standardized_resid) > 3 ~ "极端异常值",
      abs(standardized_resid) > 2 ~ "中等异常值",
      cook_distance > 4/nrow(cardio_data) ~ "高杠杆点",
      TRUE ~ "正常值"
    )
  )

# 异常值统计
table(outliers$outlier_status)

# 绘制异常值诊断图
p1 <- ggplot(outliers, aes(x = predicted, y = standardized_resid, color = outlier_status)) +
  geom_point(alpha = 0.7) +
  geom_hline(yintercept = c(-3, 3), linetype = "dashed", color = "red") +
  geom_hline(yintercept = c(-2, 2), linetype = "dashed", color = "orange") +
  scale_color_manual(values = c("#6b7280", "#f59e0b", "#ef4444", "#dc2626")) +
  labs(
    title = "标准化残差图",
    x = "预测值",
    y = "标准化残差",
    color = "异常值类型"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

p2 <- ggplot(outliers, aes(x = leverage, y = standardized_resid, size = cook_distance, color = outlier_status)) +
  geom_point(alpha = 0.6) +
  scale_size_continuous(name = "Cook距离") +
  scale_color_manual(values = c("#6b7280", "#f59e0b", "#ef4444", "#dc2626")) +
  labs(
    title = "杠杆图",
    subtitle = "气泡大小表示Cook距离",
    x = "杠杆值",
    y = "标准化残差",
    color = "异常值类型"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

p1 + p2
```

---

## 稳健回归方法

### 方法1：MASS包的rlm()

使用Huber M估计：

```{r}
# 稳健线性回归（Huber M估计）
robust_huber <- MASS::rlm(
  systolic_bp ~ age + bmi + smoking + cholesterol,
  data = cardio_data,
  method = "M"  # Huber M估计
)

summary(robust_huber)
```

### 方法2：Tukey稳健回归

使用Bisquare损失函数：

```{r}
# 稳健线性回归（Tukey Bisquare）
robust_tukey <- MASS::rlm(
  systolic_bp ~ age + bmi + smoking + cholesterol,
  data = cardio_data,
  method = "MM"  # MM估计（更稳健）
)

summary(robust_tukey)
```

### 方法3：分位数回归

使用中位数回归（50%分位数）：

```{r}
# 分位数回归
library(quantreg)

# 中位数回归（稳健替代OLS）
rq_median <- rq(
  systolic_bp ~ age + bmi + smoking + cholesterol,
  data = cardio_data,
  tau = 0.5
)

summary(rq_median)

# 比较不同分位数
rq_comparison <- rq(
  systolic_bp ~ age + bmi + smoking + cholesterol,
  data = cardio_data,
  tau = c(0.25, 0.5, 0.75)
)

summary(rq_comparison)
```

### 方法4：稳健标准误

使用异方差稳健标准误：

```{r}
# 传统OLS + 稳健标准误
library(sandwich)
library(lmtest)

# 拟合传统模型
ols_robust_se <- lm(systolic_bp ~ age + bmi + smoking + cholesterol, data = cardio_data)

# 计算稳健标准误
robust_se <- vcovHC(ols_robust_se, type = "HC3")

# 稳健t检验
coeftest(ols_robust_se, vcov = robust_se)
```

---

## 模型比较与诊断

### 参数估计比较

```{r}
# 提取各模型的系数
model_comparison <- data.frame(
  Method = c("OLS", "Huber RLM", "Tukey RLM", "Median Regression"),
  
  Intercept = c(
    coef(ols_model)[1],
    coef(robust_huber)[1],
    coef(robust_tukey)[1],
    coef(rq_median)[1]
  ),
  
  Age = c(
    coef(ols_model)["age"],
    coef(robust_huber)["age"],
    coef(robust_tukey)["age"],
    coef(rq_median)["age"]
  ),
  
  BMI = c(
    coef(ols_model)["bmi"],
    coef(robust_huber)["bmi"],
    coef(robust_tukey)["bmi"],
    coef(rq_median)["bmi"]
  ),
  
  Smoking = c(
    coef(ols_model)["smoking"],
    coef(robust_huber)["smoking"],
    coef(robust_tukey)["smoking"],
    coef(rq_median)["smoking"]
  )
)

model_comparison
```

### 残差分析

```{r fig.height=8}
# 计算各模型的残差
residuals_data <- cardio_data |>
  mutate(
    ols_pred = fitted(ols_model),
    huber_pred = fitted(robust_huber),
    tukey_pred = fitted(robust_tukey),
    median_pred = fitted(rq_median),
    
    ols_resid = systolic_bp - ols_pred,
    huber_resid = systolic_bp - huber_pred,
    tukey_resid = systolic_bp - tukey_pred,
    median_resid = systolic_bp - median_pred
  ) |>
  pivot_longer(
    cols = c(ols_resid, huber_resid, tukey_resid, median_resid),
    names_to = "model",
    values_to = "residual"
  ) |>
  mutate(
    model = case_when(
      model == "ols_resid" ~ "OLS",
      model == "huber_resid" ~ "Huber RLM",
      model == "tukey_resid" ~ "Tukey RLM", 
      model == "median_resid" ~ "Median Reg"
    )
  )

# 残差分布比较
p1 <- residuals_data |>
  ggplot(aes(x = residual, fill = model, color = model)) +
  geom_histogram(alpha = 0.6, position = "identity", bins = 30) +
  scale_fill_brewer(palette = "Set2") +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = "残差分布比较",
    x = "残差",
    y = "频数"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")

# 残差vs拟合值
p2 <- residuals_data |>
  ggplot(aes(x = systolic_bp, y = residual, color = model)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 0, linetype = "dashed") +
  geom_smooth(se = FALSE, method = "loess") +
  facet_wrap(~model) +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = "残差 vs 拟合值",
    x = "实际收缩压",
    y = "残差"
  ) +
  theme_minimal() +
  theme(legend.position = "none")

p1 / p2
```

### 稳健性检验

```{r}
# 计算各模型的诊断统计量
diagnostic_stats <- data.frame(
  Method = c("OLS", "Huber RLM", "Tukey RLM", "Median Reg"),
  
  RMSE = c(
    sqrt(mean(residuals_data$residual[residuals_data$model == "OLS"]^2)),
    sqrt(mean(residuals_data$residual[residuals_data$model == "Huber RLM"]^2)),
    sqrt(mean(residuals_data$residual[residuals_data$model == "Tukey RLM"]^2)),
    sqrt(mean(residuals_data$residual[residuals_data$model == "Median Reg"]^2))
  ),
  
  MAE = c(
    mean(abs(residuals_data$residual[residuals_data$model == "OLS"])),
    mean(abs(residuals_data$residual[residuals_data$model == "Huber RLM"])),
    mean(abs(residuals_data$residual[residuals_data$model == "Tukey RLM"])),
    mean(abs(residuals_data$residual[residuals_data$model == "Median Reg"]))
  )
) |>
  mutate(
    across(c(RMSE, MAE), ~round(.x, 2))
  )

diagnostic_stats
```

### 影响分析

```{r}
# Cook距离比较
p1 <- data.frame(
  obs = 1:nrow(cardio_data),
  ols_cooks = cooks.distance(ols_model),
  huber_cooks = cooks.distance(robust_huber)
) |>
  pivot_longer(cols = c(ols_cooks, huber_cooks), names_to = "method", values_to = "cooks") |>
  mutate(method = ifelse(method == "ols_cooks", "OLS", "Huber RLM")) |>
  ggplot(aes(x = obs, y = cooks, color = method)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 4/nrow(cardio_data), linetype = "dashed") +
  scale_color_manual(values = c("#ef4444", "#4f46e5")) +
  labs(
    title = "Cook距离比较",
    subtitle = "虚线表示临界值",
    x = "观测值",
    y = "Cook距离",
    color = "方法"
  ) +
  theme_minimal()

# 杠杆值比较
p2 <- data.frame(
  obs = 1:nrow(cardio_data),
  ols_leverage = hatvalues(ols_model),
  huber_leverage = hatvalues(robust_huber)
) |>
  pivot_longer(cols = c(ols_leverage, huber_leverage), names_to = "method", values_to = "leverage") |>
  mutate(method = ifelse(method == "ols_leverage", "OLS", "Huber RLM")) |>
  ggplot(aes(x = obs, y = leverage, color = method)) +
  geom_point(alpha = 0.6) +
  geom_hline(yintercept = 2 * ncol(model.matrix(ols_model)) / nrow(cardio_data), 
             linetype = "dashed") +
  scale_color_manual(values = c("#ef4444", "#4f46e5")) +
  labs(
    title = "杠杆值比较",
    subtitle = "虚线表示临界值",
    x = "观测值",
    y = "杠杆值",
    color = "方法"
  ) +
  theme_minimal()

p1 + p2
```

---

## 稳健预测与验证

### 留一交叉验证

```{r}
# 稳健回归留一交叉验证
leave_one_out_robust <- function(data, formula, method = c("huber", "tukey", "ols")) {
  
  n <- nrow(data)
  predictions <- numeric(n)
  
  for(i in 1:n) {
    # 排除第i个观测
    train_data <- data[-i, ]
    test_data <- data[i, , drop = FALSE]
    
    # 根据方法选择模型
    if(method == "ols") {
      model <- lm(formula, data = train_data)
    } else if(method == "huber") {
      model <- MASS::rlm(formula, data = train_data, method = "M")
    } else if(method == "tukey") {
      model <- MASS::rlm(formula, data = train_data, method = "MM")
    }
    
    # 预测
    predictions[i] <- predict(model, newdata = test_data)
  }
  
  return(predictions)
}

# 执行交叉验证
set.seed(20250124)

cv_ols <- leave_one_out_robust(cardio_data, 
                               systolic_bp ~ age + bmi + smoking + cholesterol, 
                               method = "ols")

cv_huber <- leave_one_out_robust(cardio_data,
                                 systolic_bp ~ age + bmi + smoking + cholesterol,
                                 method = "huber")

cv_tukey <- leave_one_out_robust(cardio_data,
                                 systolic_bp ~ age + bmi + smoking + cholesterol,
                                 method = "tukey")

# 计算预测性能
cv_performance <- data.frame(
  Method = c("OLS", "Huber RLM", "Tukey RLM"),
  
  RMSE = c(
    sqrt(mean((cardio_data$systolic_bp - cv_ols)^2)),
    sqrt(mean((cardio_data$systolic_bp - cv_huber)^2)),
    sqrt(mean((cardio_data$systolic_bp - cv_tukey)^2))
  ),
  
  MAE = c(
    mean(abs(cardio_data$systolic_bp - cv_ols)),
    mean(abs(cardio_data$systolic_bp - cv_huber)),
    mean(abs(cardio_data$systolic_bp - cv_tukey))
  ),
  
  R2 = c(
    1 - sum((cardio_data$systolic_bp - cv_ols)^2) / sum((cardio_data$systolic_bp - mean(cardio_data$systolic_bp))^2),
    1 - sum((cardio_data$systolic_bp - cv_huber)^2) / sum((cardio_data$systolic_bp - mean(cardio_data$systolic_bp))^2),
    1 - sum((cardio_data$systolic_bp - cv_tukey)^2) / sum((cardio_data$systolic_bp - mean(cardio_data$systolic_bp))^2)
  )
) |>
  mutate(
    across(c(RMSE, MAE, R2), ~round(.x, 3))
  )

cv_performance
```

### 预测可视化

```{r}
# 交叉验证预测对比
cv_data <- cardio_data |>
  mutate(
    cv_pred_ols = cv_ols,
    cv_pred_huber = cv_huber,
    cv_pred_tukey = cv_tukey
  ) |>
  pivot_longer(
    cols = starts_with("cv_pred_"),
    names_to = "method",
    values_to = "predicted"
  ) |>
  mutate(
    method = case_when(
      method == "cv_pred_ols" ~ "OLS",
      method == "cv_pred_huber" ~ "Huber RLM",
      method == "cv_pred_tukey" ~ "Tukey RLM"
    )
  )

# 预测 vs 实际值
ggplot(cv_data, aes(x = systolic_bp, y = predicted, color = method)) +
  geom_point(alpha = 0.6) +
  geom_abline(intercept = 0, slope = 1, linetype = "dashed", color = "black") +
  geom_smooth(method = "lm", se = FALSE, color = "red", aes(color = NULL)) +
  facet_wrap(~method) +
  coord_equal() +
  scale_color_brewer(palette = "Set2") +
  labs(
    title = "交叉验证预测性能",
    subtitle = "虚线为理想预测线，红色线为实际拟合线",
    x = "实际收缩压",
    y = "预测收缩压"
  ) +
  theme_minimal() +
  theme(legend.position = "none")
```

---

## 稳健标准误与统计推断

### HAC稳健标准误

```{r}
# Newey-West HAC标准误
library(sandwich)

# 计算HAC标准误
hac_se <- vcovHAC(ols_model, type = "HAC")
hac_test <- coeftest(ols_model, vcov = hac_se)

# 比较不同标准误
standard_error_comparison <- data.frame(
  Variable = rownames(coef(summary(ols_model))),
  OLS_SE = summary(ols_model)$coefficients[, "Std. Error"],
  Robust_SE = sqrt(diag(hac_se)),
  HAC_SE = sqrt(diag(hac_se))  # 对于截面数据，HAC和稳健SE相似
) |>
  mutate(
    across(c(OLS_SE, Robust_SE, HAC_SE), ~round(.x, 2)),
    SE_ratio = round(Robust_SE / OLS_SE, 2)
  )

standard_error_comparison
```

### 稳健置信区间

```{r}
# 稳健置信区间
robust_confint <- confint(robust_huber, level = 0.95)

# 置信区间宽度比较
ols_ci <- confint(ols_model, level = 0.95)

ci_comparison <- data.frame(
  Variable = rownames(robust_confint),
  OLS_CI_width = ols_ci[, 2] - ols_ci[, 1],
  Huber_CI_width = robust_confint[, 2] - robust_confint[, 1]
) |>
  mutate(
    across(c(OLS_CI_width, Huber_CI_width), ~round(.x, 2)),
    Coverage_improvement = round(Huber_CI_width / OLS_CI_width, 2)
  )

ci_comparison
```

---

## 流行病学应用案例

### 案例：心血管风险因素分析

**研究问题**：哪些因素独立影响血压水平？

**研究设计**：横断面研究，N=500

**主要发现**：

```{r}
# 完整的稳健回归分析
final_robust_model <- MASS::rlm(
  systolic_bp ~ age + bmi + smoking + cholesterol + sex,
  data = cardio_data,
  method = "MM"
)

# 模型摘要
summary(final_robust_model)

# 手动创建诊断图
robust_diag_data <- data.frame(
  Fitted = fitted(final_robust_model),
  Residuals = residuals(final_robust_model)
)

p1 <- ggplot(robust_diag_data, aes(x = Fitted, y = Residuals)) +
  geom_point(alpha = 0.5) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  geom_smooth(se = FALSE, color = "blue") +
  labs(
    title = "稳健残差 vs 拟合值",
    subtitle = "Huber MM估计",
    x = "拟合值",
    y = "残差"
  ) +
  theme_minimal()

p2 <- ggplot(robust_diag_data, aes(sample = Residuals)) +
  stat_qq() +
  stat_qq_line(color = "red") +
  labs(
    title = "稳健QQ图",
    subtitle = "检查正态性"
  ) +
  theme_minimal()

p1 + p2

# 系数可视化
coef_plot_data <- data.frame(
  Variable = names(coef(final_robust_model))[-1],  # 排除截距
  Coefficient = coef(final_robust_model)[-1],
  SE = sqrt(diag(vcov(final_robust_model)))[-1],
  Lower_CI = coef(final_robust_model)[-1] - 1.96 * sqrt(diag(vcov(final_robust_model)))[-1],
  Upper_CI = coef(final_robust_model)[-1] + 1.96 * sqrt(diag(vcov(final_robust_model)))[-1]
)

ggplot(coef_plot_data, aes(x = Coefficient, y = Variable)) +
  geom_point(size = 2, color = "#4f46e5") +
  geom_errorbarh(aes(xmin = Lower_CI, xmax = Upper_CI), height = 0.2, color = "#4f46e5") +
  geom_vline(xintercept = 0, linetype = "dashed", alpha = 0.5) +
  labs(
    title = "稳健回归系数（95%置信区间）",
    subtitle = "心血管风险因素分析",
    x = "回归系数",
    y = "变量"
  ) +
  theme_minimal()
```

### 结果解释模板

**方法描述**：
> 采用稳健线性回归（Huber M估计）分析血压与潜在风险因素的关系。该方法能够抵抗异常值的影响，提供更稳健的估计。采用留一交叉验证评估模型预测性能。

**主要结果**：
- **年龄效应**：每增加1岁，收缩压平均增加0.8 mmHg（95% CI: 0.6-1.0）
- **BMI效应**：BMI每增加1 kg/m²，收缩压增加0.6 mmHg（95% CI: 0.4-0.8）
- **吸烟效应**：吸烟者收缩压比非吸烟者高15 mmHg（95% CI: 10-20）
- **模型稳健性**：稳健回归的交叉验证RMSE为12.3，优于传统OLS的14.1

**临床意义**：
> 控制年龄、BMI和吸烟是降低心血管风险的重要策略。结果显示，即使在存在异常值的情况下，这些关联仍然稳健。

---

## 高级主题

### 多变量稳健回归诊断

```{r}
# Cook距离阈值的稳健版本
robust_cook_threshold <- function(model, method = "huber") {
  n <- nobs(model)
  p <- length(coef(model))
  
  if(method == "huber" || method == "tukey") {
    # 稳健版本：基于稳健残差标准误
    robust_sigma <- summary(model)$sigma
    critical_value <- sqrt(4 / n) * robust_sigma
    return(critical_value)
  } else {
    return(4 / n)
  }
}

# 计算各模型阈值
thresholds <- data.frame(
  Method = c("OLS", "Huber RLM", "Tukey RLM"),
  Threshold = c(
    robust_cook_threshold(ols_model, "ols"),
    robust_cook_threshold(robust_huber, "huber"),
    robust_cook_threshold(robust_tukey, "tukey")
  )
)

thresholds
```

### 稳健性敏感性分析

```{r}
# 敏感性分析：逐步移除影响点
sensitivity_analysis <- function(data, model_formula, n_remove = 1:20) {
  
  results <- data.frame(
    n_removed = integer(),
    method = character(),
    rmse = numeric(),
    coefficient_stability = numeric()
  )
  
  # 基准模型
  base_coef <- coef(MASS::rlm(model_formula, data = data, method = "MM"))
  
  for(n_rem in n_remove) {
    # 随机移除n_rem个观测
    remove_indices <- sample(nrow(data), n_rem)
    reduced_data <- data[-remove_indices, ]
    
    # 重新拟合模型
    reduced_model <- MASS::rlm(model_formula, data = reduced_data, method = "MM")
    
    # 计算系数稳定性
    current_coef <- coef(reduced_model)
    stability <- cor(base_coef, current_coef)
    
    # 计算RMSE
    predictions <- fitted(reduced_model)
    rmse <- sqrt(mean((reduced_data$systolic_bp - predictions)^2))
    
    results <- rbind(results, 
                     data.frame(
                       n_removed = n_rem,
                       method = "Huber",
                       rmse = rmse,
                       coefficient_stability = stability
                     ))
  }
  
  return(results)
}

# 执行敏感性分析
sensitivity_results <- sensitivity_analysis(
  cardio_data,
  systolic_bp ~ age + bmi + smoking + cholesterol
)

# 可视化敏感性
ggplot(sensitivity_results, aes(x = n_removed, y = coefficient_stability)) +
  geom_point(color = "#4f46e5", size = 2) +
  geom_line(color = "#4f46e5") +
  geom_hline(yintercept = 0.95, linetype = "dashed", color = "red") +
  labs(
    title = "稳健性敏感性分析",
    subtitle = "移除不同数量观测后的系数稳定性",
    x = "移除观测数",
    y = "系数相关性（vs 基准模型）"
  ) +
  theme_minimal()
```

### 自定义稳健损失函数

```{r}
# 实现自定义损失函数
custom_robust_loss <- function(x, k = 1.345) {
  # 实现Fair损失函数
  c <- k
  result <- c^2 * (abs(x/c) - log(1 + abs(x/c)))
  return(result)
}

# 手动实现稳健回归（使用自定义损失）
manual_robust_regression <- function(y, X, loss_function = custom_robust_loss, 
                                     max_iter = 100, tolerance = 1e-6) {
  
  n <- length(y)
  p <- ncol(X)
  
  # 初始估计（使用OLS）
  beta <- solve(t(X) %*% X) %*% t(X) %*% y
  weights <- rep(1, n)
  
  for(iter in 1:max_iter) {
    # 预测
    y_pred <- X %*% beta
    
    # 残差
    residuals <- y - y_pred
    
    # 计算权重（使用MAD标准化，增加稳定性）
    mad_scale <- median(abs(residuals - median(residuals))) / 0.6745
    standardized_residuals <- residuals / (mad_scale + 1e-10)
    
    # Huber权重函数
    k <- 1.345
    weights <- ifelse(abs(standardized_residuals) <= k, 1, 
                     k / abs(standardized_residuals))
    
    # 确保权重在合理范围内
    weights <- pmax(weights, 1e-6)
    weights <- pmin(weights, 1)
    
    # 加权最小二乘
    W <- diag(as.vector(weights))
    XtWX <- t(X) %*% W %*% X
    
    # 添加正则化防止奇异矩阵
    XtWX_reg <- XtWX + diag(1e-8, ncol(X))
    
    beta_new <- solve(XtWX_reg) %*% t(X) %*% W %*% y
    
    # 检查收敛
    if(max(abs(beta_new - beta)) < tolerance) {
      break
    }
    
    beta <- beta_new
  }
  
  # 计算标准误
  residuals_final <- y - X %*% beta
  sigma <- sqrt(sum(weights * residuals_final^2) / (n - p))
  se <- sigma * sqrt(diag(solve(t(X) %*% W %*% X + diag(1e-8, ncol(X)))))
  
  return(list(coefficients = beta, standard_errors = se, 
              weights = weights, iterations = iter))
}

# 应用自定义稳健回归
X <- model.matrix(~ age + bmi + smoking + cholesterol, data = cardio_data)
y <- cardio_data$systolic_bp

manual_result <- manual_robust_regression(y, X)

# 比较结果
comparison <- data.frame(
  Variable = colnames(X),
  Manual_Robust = as.vector(manual_result$coefficients),
  Manual_SE = manual_result$standard_errors
)

comparison
```

---

## 总结

### 稳健回归方法选择指南

| 数据特征 | 推荐方法 | 原因 |
|----------|----------|------|
| 少量异常值 | Huber M估计 | 平衡稳健性与效率 |
| 大量异常值 | Tukey Bisquare | 高度稳健性 |
| 偏态分布 | 分位数回归 | 无分布假设 |
| 异方差 | 稳健标准误 | 保持点估计 |
| 小样本 | 传统方法谨慎使用 | 稳健方法可能不够稳定 |

### 模型报告要点

1. **异常值诊断**：报告异常值检测方法和数量
2. **方法选择**：说明选择特定稳健方法的原因
3. **诊断统计**：提供RMSE、MAE、Cook距离等
4. **稳健性检验**：包含敏感性分析结果
5. **比较分析**：与传统OLS的详细对比

### R包推荐

| 包名 | 主要功能 | 推荐使用场景 |
|------|----------|--------------|
| `MASS::rlm()` | 稳健线性回归 | 基本稳健回归分析 |
| `quantreg::rq()` | 分位数回归 | 偏态分布数据 |
| `robustlmm` | 分层稳健模型 | 多层数据结构 |
| `sandwich` | 稳健标准误 | 异方差处理 |
| `car` | 扩展诊断 | 高级模型诊断 |

---

**提示**：稳健回归是处理复杂数据的有力工具，但应始终结合领域知识和数据探索结果选择合适的方法。在实际应用中，建议多种方法比较，并进行充分的稳健性检验。