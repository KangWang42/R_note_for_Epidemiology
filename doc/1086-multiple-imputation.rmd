---
title: 多重插补完整教程
subtitle: "缺失数据的系统处理与稳健推断"
date: "2026-01-18"
image: images/1086-multiple-imputation-cover.svg
categories:
- 统计分析方法
- 高级建模
- 缺失数据
- multiple imputation
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width = 7.2,
  fig.height = 4.8,
  dpi = 150,
  out.width = "100%",
  fig.path = "figure/1086-mi-"
)
```

```{r packages}
library(dplyr)
library(ggplot2)
library(mice)
library(broom)
```

## 方法背景与适用场景

多重插补（Multiple Imputation, MI）是缺失数据处理中最稳健的方法之一。
它通过“多次补全数据 + 多次建模 + 汇总结果”，降低单次插补的不确定性。

它适合缺失比例中等、但不能简单删除样本的研究，尤其在需要维持样本量与统计效能时非常关键。如果缺失机制至少可视为 MCAR 或 MAR，多重插补往往能给出更稳健的推断。
## 模型入门与核心概念

多重插补的核心流程可以概括为三个环节：先基于已有变量生成多个“完整数据集”，再在每个数据集上独立建模，最后用 Rubin 法则汇总系数和标准误。它的关键优势是把“缺失的不确定性”保留下来，避免单次插补带来的过度自信。
## 模型假设与前提

多重插补要求缺失机制至少是 MAR（Missing At Random），插补模型应包含与缺失相关的关键变量，并保证每次插补彼此独立。只要这些条件大体成立，MI 的推断通常比完全案例更可靠。
## 通俗举例：为什么不能直接删掉缺失样本

如果你把缺失样本全部删除，样本量会变小，统计效能下降。
更严重的是：如果缺失并不是随机的（例如高 BMI 人群更容易缺失），
直接删除会改变样本结构，让结论偏向“更健康的人群”。

多重插补的价值就在于：它尽量保留原始样本结构，并把缺失的不确定性
转化为统计推断的一部分。

## 方法对比：完全案例 vs 单次插补 vs 多重插补

完全案例分析简单但可能有偏倚，同时会显著降低样本量；单次插补看似补全了数据，却低估了插补的不确定性；多重插补在保留样本量的同时量化插补误差，因此更适合作为常规缺失处理策略。

## 数据准备与缺失模式

```{r mi-data}
set.seed(2026)
base_data <- tibble::tibble(
  age = round(rnorm(200, 45, 12), 1),
  bmi = round(rnorm(200, 24, 4), 1),
  smoke = sample(c("yes", "no"), 200, replace = TRUE),
  outcome = rnorm(200, 5, 1.5)
)

missing_data <- base_data |>
  mutate(
    bmi = if_else(runif(200) < 0.2, NA_real_, bmi),
    outcome = if_else(runif(200) < 0.15, NA_real_, outcome)
  )

mice::md.pattern(missing_data)
```

## 分析流程步骤

分析流程可以理解为四步：先检查缺失模式并确定合适的插补方法，再执行多重插补，随后在每个插补数据集上分别建模，最后用 Rubin 法则汇总结果并解释不确定性。这种分阶段思路能帮助读者理解“插补只是第一步，推断仍要回到模型上”。

## 参数讲解与使用要点

`m` 代表插补数据集数量，通常建议 5–10；`method` 是插补方法，连续变量常用 `pmm`，分类变量可用 `logreg`；`maxit` 是迭代次数，太少会导致插补不稳定；`seed` 用于保证可复现。通常缺失比例越高，`m` 应越大；模型越复杂，插补模型也要包含这些关键变量。

## 代码实现

### 多重插补

```{r mi-impute}
set.seed(2026)
imp <- mice(
  missing_data,
  m = 5,
  method = "pmm",
  maxit = 10,
  seed = 2026
)

imp
```

```{r mi-diagnostics}
plot(imp)
```

### 在插补数据上建模

```{r mi-model}
mi_fit <- with(
  imp,
  lm(outcome ~ age + bmi + smoke)
)

mi_fit
```

### 汇总结果

```{r mi-pool}
pooled <- pool(mi_fit)
summary(pooled)
```

## 结果解读与报告

```{r mi-tidy}
pooled_summary <- summary(pooled) |>
  as.data.frame()

pooled_summary
```

```{r mi-plot}
pooled_summary |>
  filter(term != "(Intercept)") |>
  ggplot(aes(x = estimate, y = term)) +
  geom_point(size = 3, color = "#2563eb") +
  geom_errorbarh(aes(xmin = estimate - 1.96 * std.error, xmax = estimate + 1.96 * std.error), height = 0.2) +
  labs(
    title = "多重插补后的回归系数",
    x = "估计值 (95% CI)",
    y = NULL
  ) +
  theme_minimal(base_size = 12)
```

**报告建议**

- 报告插补次数 `m` 与插补方法（如 pmm）。
- 对比完全案例分析与插补分析的差异。
- 提示缺失机制假设与敏感性分析。

## 常见错误与纠偏

常见问题包括插补模型过于简单、插补次数太少、忽视缺失机制以及误把单个插补结果当最终结论。解决方式是把与缺失相关的变量纳入插补模型，保证足够的 `m`，并始终用 `pool()` 汇总结果，同时对可能的 MNAR 做敏感性分析。

## 进阶扩展

进阶做法包括尝试 `mice::cart` 或 `mice::rf` 等非参数插补方法，对分类变量使用 `logreg` 或 `polyreg`，并通过 `mice::complete()` 检查插补数据是否合理。这些步骤能提高插补模型的鲁棒性。
## 总结

多重插补是处理缺失数据的标准方法，兼顾效率与稳健性。
只要合理选择插补模型和变量，就能显著提高推断可信度。